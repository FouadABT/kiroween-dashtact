---
inclusion: always
---

# Database Sync Guidelines

## Overview
This project uses **Prisma** as the ORM with **PostgreSQL** as the database. Database sync ensures that schema changes, type definitions, and data models remain consistent between the backend (NestJS) and frontend (Next.js).

## Database Architecture

### Current Setup
- **Database**: PostgreSQL running on `localhost:5432`
- **ORM**: Prisma with client generation
- **Backend**: NestJS with Prisma integration
- **Frontend**: Next.js consuming backend APIs
- **Generated Client**: Located at `backend/generated/prisma`

## Prisma Configuration

### Schema Location
- **Schema File**: `backend/prisma/schema.prisma`
- **Generated Client**: `backend/generated/prisma`
- **Database URL**: Configured in `backend/.env`

### Key Prisma Commands (run in `backend/` directory)
```bash
npm run prisma:generate    # Generate Prisma client after schema changes
npm run prisma:migrate     # Create and apply database migrations
npm run prisma:studio      # Open Prisma Studio for data management
npm run prisma:seed        # Run database seeding (if seed.ts exists)
```

## Database Sync Workflow

### 1. Schema Changes
When modifying database schema:

1. **Update Schema**: Edit `backend/prisma/schema.prisma`
2. **Generate Migration**: Run `npm run prisma:migrate` in backend
3. **Generate Client**: Run `npm run prisma:generate` in backend
4. **Update Backend Services**: Modify NestJS services to use new schema
5. **Update Frontend Types**: Create/update TypeScript interfaces for API responses
6. **Update API Endpoints**: Modify controllers to handle new data structure

### 2. Type Synchronization

#### Backend Types (Auto-generated)
```typescript
// Generated by Prisma in backend/generated/prisma
import { PrismaClient } from '../generated/prisma';

// Example service usage
@Injectable()
export class UserService {
  constructor(private prisma: PrismaClient) {}
  
  async findAll() {
    return this.prisma.user.findMany();
  }
}
```

#### Frontend Types (Manual sync)
```typescript
// frontend/src/types/api.ts
export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: string;
  updatedAt: string;
}

export interface ApiResponse<T> {
  data: T;
  message?: string;
  error?: string;
}
```

### 3. API Integration Pattern

#### Backend Controller Pattern
```typescript
// backend/src/[feature]/[feature].controller.ts
@Controller('[feature]')
export class FeatureController {
  constructor(private readonly featureService: FeatureService) {}

  @Get()
  async findAll(): Promise<Feature[]> {
    return this.featureService.findAll();
  }
}
```

#### Frontend API Client Pattern
```typescript
// frontend/src/lib/api.ts (create if missing)
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export class ApiClient {
  static async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${API_BASE_URL}${endpoint}`);
    if (!response.ok) throw new Error('API request failed');
    return response.json();
  }
}
```

## Development Best Practices

### 1. Schema Design
- Use descriptive model names (PascalCase)
- Include `createdAt` and `updatedAt` fields for audit trails
- Define proper relationships with foreign keys
- Use enums for fixed value sets

### 2. Migration Strategy
- Always create migrations for schema changes
- Never edit existing migrations
- Use descriptive migration names
- Test migrations on development data first

### 3. Type Safety
- Generate Prisma client after every schema change
- Keep frontend types in sync with backend models
- Use TypeScript strict mode in both projects
- Create shared type definitions for API contracts

### 4. Data Validation
- Use Prisma schema validation
- Add NestJS DTOs for request validation
- Implement frontend form validation
- Handle database constraints gracefully

## Common Sync Tasks

### Adding a New Model
1. Add model to `backend/prisma/schema.prisma`
2. Run `npm run prisma:migrate` in backend
3. Run `npm run prisma:generate` in backend
4. Create NestJS module/service/controller
5. Add frontend TypeScript types
6. Create API client methods
7. Update frontend components

### Modifying Existing Model
1. Update model in `backend/prisma/schema.prisma`
2. Run `npm run prisma:migrate` in backend
3. Run `npm run prisma:generate` in backend
4. Update backend services using the model
5. Update frontend types to match changes
6. Update API client methods if needed
7. Update frontend components using the data

### Database Reset (Development Only)
```bash
# In backend directory
npx prisma migrate reset    # Resets database and applies all migrations
npm run prisma:generate     # Regenerate client
npm run prisma:seed         # Reseed data (if seed script exists)
```

## Environment Configuration

### Backend Environment Variables
```env
# backend/.env
DATABASE_URL="postgresql://username:password@localhost:5432/dbname?schema=public"
PORT=3001
NODE_ENV=development
```

### Frontend Environment Variables
```env
# frontend/.env.local
NEXT_PUBLIC_API_URL=http://localhost:3001
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=development
```

## Automated Verification & Testing

### Verification Script
Run the automated sync verification script to check consistency:
```bash
node .kiro/scripts/verify-prisma-sync.js
```

This script will:
- Check if Prisma schema exists
- Verify frontend types directory
- Compare Prisma models with frontend TypeScript interfaces
- Identify missing or mismatched fields
- Check if Prisma client is generated
- Provide a detailed report of any issues

### Test Generation
After schema changes, generate comprehensive backend tests:
```bash
node .kiro/scripts/generate-sync-tests.js
```

This will create/update:
- Service unit tests (*.service.spec.ts)
- CRUD operation tests
- Type safety validation tests
- Error handling tests

### Manual Verification Checklist
After any schema sync, verify:
1. ✅ Prisma client generates without errors: `npm run prisma:generate`
2. ✅ Backend compiles: `npm run build` in backend/
3. ✅ Frontend compiles: `npm run build` in frontend/
4. ✅ Tests pass: `npm test` in backend/
5. ✅ Types match: Run verification script
6. ✅ API endpoints return correct data structure

## Troubleshooting

### Common Issues
1. **Prisma Client Out of Sync**: Run `npm run prisma:generate`
2. **Migration Conflicts**: Reset database in development
3. **Type Mismatches**: Run `.kiro/scripts/verify-prisma-sync.js` to identify issues
4. **Connection Issues**: Verify DATABASE_URL and PostgreSQL service
5. **Test Failures**: Regenerate tests with `generate-sync-tests.js`

### Debugging Commands
```bash
# Check database connection
npx prisma db pull

# View current schema
npx prisma db seed

# Reset everything (development only)
npx prisma migrate reset

# Verify sync status
node .kiro/scripts/verify-prisma-sync.js

# Generate tests for all models
node .kiro/scripts/generate-sync-tests.js
```

## File Organization

### Backend Database Files
```
backend/
├── prisma/
│   ├── schema.prisma       # Database schema definition
│   ├── migrations/         # Generated migration files
│   └── seed.ts            # Database seeding script
├── generated/
│   └── prisma/            # Generated Prisma client
└── src/
    └── [feature]/         # Feature modules using Prisma
```

### Frontend API Integration Files
```
frontend/
├── src/
│   ├── lib/
│   │   └── api.ts         # API client configuration
│   ├── types/
│   │   ├── api.ts         # API response types
│   │   └── [feature].ts   # Feature-specific types
│   └── hooks/
│       └── use-api.ts     # Custom hooks for API calls
```


## Agent Hook: Prisma Database Sync

### Overview
The **Prisma Database Sync Agent** hook automatically monitors file changes and maintains consistency across your full stack. It's located at `.kiro/hooks/prisma-sync-agent.kiro.hook`.

### What It Monitors
The hook watches for changes to:
- `backend/prisma/schema.prisma` - Database schema
- `frontend/src/types/*.ts` - Frontend type definitions
- `backend/src/**/*.entity.ts` - Backend entities
- `backend/src/**/*.dto.ts` - Data transfer objects
- `frontend/src/lib/api.ts` - API client

### What It Does Automatically
When a monitored file changes, the agent:

1. **Analyzes Changes**: Identifies what was modified and potential impacts
2. **Safety Check**: Verifies changes won't break existing functionality
3. **Backend Sync**: 
   - Generates Prisma migrations
   - Regenerates Prisma client
   - Updates services and controllers
   - Updates DTOs
4. **Frontend Sync**:
   - Updates TypeScript interfaces
   - Syncs API client methods
   - Ensures type consistency
5. **Testing**:
   - Generates/updates service tests
   - Validates CRUD operations
   - Checks type safety
6. **Verification**:
   - Compares frontend and backend types
   - Runs automated checks
   - Reports any inconsistencies
7. **Reports**: Provides comprehensive summary with:
   - Changes made
   - Test results
   - Breaking changes
   - Manual verification steps
   - Rollback instructions

### Safety Features
The agent follows strict safety rules:
- ⚠️ Never deletes existing migrations
- ⚠️ Always verifies types match before completing
- ⚠️ Creates tests before marking sync complete
- ⚠️ Checks for compilation errors after each change
- ⚠️ Stops and reports if verification fails
- ⚠️ Preserves existing functionality
- ⚠️ Uses minimal, focused changes
- ⚠️ Validates all models are consistent

### Enabling/Disabling
To manage the hook:
1. Open the Agent Hooks view in Kiro explorer
2. Find "Prisma Database Sync Agent"
3. Toggle enabled/disabled
4. Or edit `.kiro/hooks/prisma-sync-agent.kiro.hook` directly

### Manual Override
If you prefer manual control:
1. Disable the hook
2. Use the verification script: `node .kiro/scripts/verify-prisma-sync.js`
3. Generate tests manually: `node .kiro/scripts/generate-sync-tests.js`
4. Follow the standard sync workflow above
